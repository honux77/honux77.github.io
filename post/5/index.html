<!doctype html><html lang=ko><head><title>Honux BBS</title><meta charset=utf-8><meta content="utf-8" http-equiv=encoding><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#000084"><meta property="og:title" content="백기선 자바 스터디 5: 클래스 - Sat, Jan 2, 2021"><meta property="og:description" content="이것이 너와 나의 클래스 차이다"><meta property="og:image" content="https://honux77.github.io//img/hugo-og.png"><link rel=icon href=https://honux77.github.io//favicon.ico><link rel=canonical href=https://honux77.github.io/></head><body><nav class="navbar navbar-inverse navbar-fixed-top"><div class=navbar-inner><div class=container><button type=button class="btn btn-navbar" data-toggle=collapse data-target=.nav-collapse></button>
<a class=brand href=https://honux77.github.io/>Honux BBS</a><div class="nav-collapse collapse"><ul class=nav><li><a href=/about/><span>About</span></a></li><li><a href=/post/><span>All posts</span></a></li></ul></div></div></div></nav><div id=content class=container><div class="row-fluid navmargin"><div class=page-header><h1>백기선 자바 스터디 5: 클래스 - Sat, Jan 2, 2021</h1></div><p class=lead>이것이 너와 나의 클래스 차이다</p><h2 id=참고자료>참고자료</h2><ul><li>Oracle Java SE 8 Fundamentlas (Oracle University 교재)</li><li>객체지향의 사실과 오해, 조영호</li></ul><h2 id=클래스-정의>클래스 정의</h2><pre><code>public class Hello {
	//fields of the class here
    //methods here
}
</code></pre><ul><li><code>class</code> 키워드를 이용해서 정의한다.</li><li>관습적으로 대문자로 시작한다. 카멜케이스를 주로 사용</li><li>public: modifier</li><li>멤버 변수 혹은 필드로 불리는 상태 또는를 갖을 수 있다.</li><li>메소드라 불리는 행동(behaviors) 또는 오퍼레이션(Operation)을 갖을 수 있다.</li><li>자바는 한 파일에 하나의 public 클래스만 허용한다.</li><li>클래스는 객체를 생성해 주는 도구, 레시피, 혹은 청사진(blueprint)이라고 할 수 있다.
-오브젝트의 속성(properties)과 행동(behaviors)을 정의한다.</li><li>클래스를 정의하고 이를 이용해 객체(instance)를 생성할 수 있다.</li></ul><h3 id=패키지>패키지</h3><ul><li>클래스를 위한 네임스페이스</li><li>클래스가 저장될 폴더</li><li>소문자로 시작</li></ul><pre><code>package net.honux;

public class Hello { 
</code></pre><h2 id=객체-생성>객체 생성</h2><ul><li><code>new</code> 키워드로 객체를 생성할 수 있으며 객체는 힙에 저장된다.</li><li>저장된 객체는 참조변수를 통해 접근할 수 있다.</li><li>참조변수를 통해 접근할 수 없는 객체는 gc에 의해 정리된다.</li><li>자바의 대표적인 객체는 배열과, 클래스의 인스턴스이다.</li><li>(생각) 람다도 객체인 것 같은데, 구글링 좀 해 보자.</li><li>(생각) call by reference로 동작하고 매개변수로 넣을 수 있는 건 다 객체가 아닐까 싶다.</li><li>java10부터 var 키워드를 이용하면 타입추론이 가능하다.</li></ul><pre><code>Hello h = new Hello();
var h2 = new Hello();

</code></pre><h2 id=메소드>메소드</h2><pre><code>public static int display(int value) {}
</code></pre><ul><li><p>public: 접근 한정자, public, protected, default, private의 범위를 가짐</p></li><li><p>static: static으로 선언하면 인스턴스 없이 호출 가능하지만 메소드 내에서 static이 아닌 멤버 변수를 사용할 수 없다. 왜인지는 라이프사이클을 조금 생각해 보면 알 수 있다.</p></li><li><p>int: 리턴타입, 한 번에 하나의 값 혹은 객체만 리턴 가능</p></li><li><p>(int value): 매개변수, 원시 타입은 call by vlaue, 객체는 call by reference</p></li></ul><h3 id=접근-한정자>접근 한정자</h3><table><thead><tr><th>Access Modifier</th><th>Within Class</th><th>Within Package</th><th>Outside Package by Subclass Only</th><th>Outside Package</th></tr></thead><tbody><tr><td>public</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td>protected</td><td>O</td><td>O</td><td>X</td><td>X</td></tr><tr><td>default (package private)</td><td>O</td><td>O</td><td>X</td><td>X</td></tr><tr><td>private</td><td>O</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><h3 id=-연산자>. 연산자</h3><pre><code>Hello h = new Hello();
h.sayHi();
Hello.hello();
</code></pre><ul><li>메소드를 호출하기 위해서는 . 연산자를 사용한다.</li><li>static 메소드는 <code>클래스이름.메소드이름()</code>으로 호출</li><li>non-static 메소드는 <code>참조변수이름.메소드이름()</code>으로 호출</li></ul><h3 id=main-메소드>main 메소드</h3><pre><code>public static void main(String[] args) { }
</code></pre><ul><li>프로그램을 시작하는 엔트리 포인트</li></ul><h3 id=systemoutprintln>System.out.println</h3><ul><li><p>표준출력을 위해 사용함</p></li><li><p><code>System</code>: 유용한 필드와 메소드를 가지고 있다. new로 객체를 생성할 수 없으므로, public 생성자가 없다고 추정할 수 있다.</p></li><li><p><code>System.out</code> : 스태틱 필드, PrintStream 객체이다.</p></li><li><p><code>System.out.println</code>: out 객체의 public 메소드이다.</p></li></ul><h2 id=생성자>생성자</h2><pre><code>public class Hello {

</code></pre><ul><li>생성자는 특별한 형태의 메소드로 객체를 생성할 때 사용</li><li>생성자는 리턴 타입이 없다.</li><li>생성자가 없을 경우 매개변수 없는 public 생성자가 하나 자동으로 생긴다.</li><li>생성자는 private으로 선언 가능하고 이 경우 생성자 호출로 객체를 만들 수 없다.</li><li>생성자는 메소드와 달리 직접 호출이 불가능하다.</li></ul><h2 id=this>this</h2><pre><code>public class Main {
  int x;

  // Constructor with a parameter
  public Main(int x) {
    this.x = x;
  }

  // Call the constructor
  public static void main(String[] args) {
    Main myObj = new Main(5);
    System.out.println(&quot;Value of x = &quot; + myObj.x);
  }
}
</code></pre><ul><li><code>this</code> 키워드는 생성자나 메소드안에서 현재 객체의 참조로 사용할 수 있다.</li><li>static method 안에서는 this를 사용할 수 없다. 역시 생각해 보면 유추 가능하다.</li></ul><h3 id=this의-여러가지-사용법>this의 여러가지 사용법</h3><ul><li>생성자 호출 <code>this()</code></li><li>현재 메소드 호출 <code>this.hi()</code></li><li>현재 객체 리턴 <code>return this;</code></li><li>메소드나 생성자 안에서 매개변수로 사용 가능</li></ul><hr><h2 id=기타-객체지향의-사실과-오해-1장-요약>[기타] 객체지향의 사실과 오해 1장 요약</h2><h3 id=서론>서론</h3><ul><li>객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다.</li><li>소프트웨어 객체가 실세계 사물의 모방이라는 전통적 개념은 실용적이지는 않지만, 객체지향이라는 개념을 이해하는데는 큰 도움이 될 수 있다.</li></ul><h3 id=커피-주문하기>커피 주문하기</h3><ul><li>커피 주문은 손님, 캐시어, 바리스타의 역할, 책임, 협력이라는 개념이 조화를 이루며 만들어낸다.</li><li>A는 손님 역할의 객체이고 커피를 주문할 책임을 진다.</li><li>B는 캐시어 역할의 객체이고 주문한 커피를 바리스타에게 알려준다.</li><li>C는 바리스타 역할의 객체이고 커피를 완성해서 A에게 진동벨로 알린다.</li><li>(생각) 책에는 없지만 진동벨도 객체가 아닐까?</li></ul><h3 id=요청과-응답으로-구성된-협력>요청과 응답으로 구성된 협력</h3><ul><li>요청은 연쇄적으로 발생</li><li>손님 → 주문 → 캐시어 →(손님: 진동벨, 바리스타: 주문메뉴) → 바리스타 → 제조 → (진동벨) → 손님</li><li>(생각)진동벨은 객체이면서 비동기 이벤트 처리 방식이구나.</li><li>(생각) 바리스타도 곰곰히 생각해 보면 메시지 큐를 이용해서 처리하는 듯한 느낌이 든다.</li><li>(생각) 손님은 콜백함수로 등록된 진동벨 이벤트 핸들러를 이용&mldr;</li></ul><h3 id=역할과-책임>역할과 책임</h3><ul><li>세상에 존재하는 많은 일들은 혼자서 하기에는 너무 복잡하기 때문에 책임을 가진 객체의 협력으로 일이 진행된다.</li><li>역할은 의미적으로 책임을 내포한다.</li><li>선생은 암묵적으로 학생을 가르칠 책임을 가진다.</li><li>여러 사람이 동일한 역할을 수행할 수 있다.</li><li>역할은 대체 가능성을 의미한다.</li><li>책임을 수행하는 방법은 자율적으로 선택할 수 있다.</li><li>한 사람이 동시에 여러 역할을 수행 가능하다.</li></ul><h3 id=협력-속-객체>협력 속 객체</h3><ul><li>객체는 애플리케이션의 기능 구현을 위해 존재한다.</li><li>작은 기능도 객체 혼자서는 감당할 수 없기 때문에 다른 객체와의 협력을 통해 기능을 구현한다.</li><li>객체는"협력적"이어야 한다.</li><li>객체는 &ldquo;자율적"이어야 한다.</li><li>객체는 상태와 행동을 가진 자율적인 실체이다.</li><li>객체는 자율적이기 때문에 다른 객체가 무엇(what)을 하는지는 알 수 있지만 어떻게(how) 하는지는 알 수 없다.</li></ul><h3 id=메시지>메시지</h3><ul><li>객체는 메시지를 통해 다른 객체와 협력함</li></ul><h3 id=메소드-1>메소드</h3><ul><li>객체가 메시지를 처리하는 방법</li><li>메시지를 수신한 객체가 어떤 메소드를 선택할지는 런타임에 결정됨</li></ul><h3 id=상태와-행동>상태와 행동</h3><ul><li>객체는 상태를 가지며 상태는 변경 가능</li><li>상태를 변경하는 것은 객체의 행동</li><li>행동의 결과는 상태에 의존적</li><li>행동의 순서가 결과에 영향을 미침</li></ul><h3 id=객체지향>객체지향</h3><ul><li>시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 이를 이용해 시스템을 분할하는 방법</li><li>(생각) 나는 데이터를 유관한 필드의 집합이라고 생각하는데 여기서는 객체를 관련된 책임의 집합이라고 정의하는 점이 재미있다.</li></ul><h3 id=객체지향은-클래스-중심이-아니다>객체지향은 클래스 중심이 아니다!</h3><ul><li>(생각) 대다수가 클래스 다이어그램을 가장 중요하다고 생각한다고 한다. 나는 구현할 때 여러 장의 시퀀스 다이어그램을 그려 보는 것이 가장 좋았다.</li><li>객체의 공동체가 아닌 클래스가 강하게 결합된 설계도는 유연한고 확장 가능한 애플리케이션의 구축을 방해한다.</li><li>클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하자!</li><li><strong>클래스 메소드가 아니라 객체의 역할, 책임, 협력에 집중하라!</strong></li></ul><h2 id=코딩-과제>코딩 과제</h2><ul><li><input checked disabled type=checkbox> 노드 만들기</li><li><input checked disabled type=checkbox> 트리 초기화</li><li><input checked disabled type=checkbox> DFS, BFS 구현</li><li><input checked disabled type=checkbox> postorder, preorder 추가 구현</li><li>업무로 인해 TS를 학습하고 있는데, TS generic 학습 기념으로 generic으로 구현해 봄.</li></ul><p><a href=https://github.com/honux77/whiteship-live-study/tree/week6/hnx-bst/src/main/java/net/honux/bst>과제링크</a></p><pre><code> public String bfs() {
        traveller = new StringBuffer();
        Queue&lt;Node&gt; queue = new LinkedList();
        queue.add(this.head);
        while (!queue.isEmpty()) {
            Node node = queue.remove();
            if (node == null) continue;
            traveller.append(node.getValue());
            queue.add(node.left());
            queue.add(node.right());
        }
        return traveller.toString();
    }

    private void inorder(Node&lt;T&gt; node) {
        if (node == null) return;
        inorder(node.left());
        traveller.append(node.getValue());
        inorder(node.right());
    }
</code></pre><h4><a href=https://honux77.github.io/></a></h4></div></div><footer class=container><hr class=soften><p>&copy;
<span id=thisyear>2020</span>
| <a href=//gohugo.io target=_blank>Hugo</a></p><p class=text-center><a href=https://github.com/honux77>GitHub</a></p></footer></body><link rel=stylesheet href=/css/bootstrap.css><link rel=stylesheet href=/css/bootstrap-responsive.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery.js></script><script src=/js/bootstrap-386.js></script><script src=/js/bootstrap-transition.js></script><script src=/js/bootstrap-alert.js></script><script src=/js/bootstrap-modal.js></script><script src=/js/bootstrap-dropdown.js></script><script src=/js/bootstrap-scrollspy.js></script><script src=/js/bootstrap-tab.js></script><script src=/js/bootstrap-tooltip.js></script><script src=/js/bootstrap-popover.js></script><script src=/js/bootstrap-button.js></script><script src=/js/bootstrap-collapse.js></script><script src=/js/bootstrap-carousel.js></script><script src=/js/bootstrap-typeahead.js></script><script src=/js/bootstrap-affix.js></script><script>_386={fastLoad:null,onePass:null,speedFactor:null};function ThisYear(){document.getElementById('thisyear').innerHTML=new Date().getFullYear();};</script></html>