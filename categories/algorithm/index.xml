<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Honux BBS</title><link>https://honux77.github.io/categories/algorithm/</link><description>Recent content in algorithm on Honux BBS</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 17 Nov 2020 01:45:27 +0000</lastBuildDate><atom:link href="https://honux77.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>BOJ 9205 맥주 마시면서 걸어가기</title><link>https://honux77.github.io/post/boj-9205/</link><pubDate>Tue, 17 Nov 2020 01:45:27 +0000</pubDate><guid>https://honux77.github.io/post/boj-9205/</guid><description>BOJ 9205 는 길찾기 문제이다. 정해진 기간마다 맥주를 마시면서 걷다 맥주가 부족해지기 전에 가게에 들려 맥주를 리필하고, 목적지를 찾아갈 수 있는지 여부를 출력해주면 된다.
풀이 맥주가 떨어지기 전에 갈 수 있는 최대거리는 1000미터이므로 BFS를 이용해서 1000미터 이내의 슈퍼를 방문하고 목적지까지 갈 수 있는지 여부를 확인하는 방법을 풀었다.
using namespace std; bool canWalk(pair&amp;lt;int,int&amp;gt; &amp;amp;a, pair&amp;lt;int,int&amp;gt; &amp;amp;b) { return abs(a.first - b.first) + abs(a.second - b.second) &amp;lt;= 1000; } void bfs(vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;a) { vector&amp;lt;bool&amp;gt; visited(a.</description></item><item><title>[알고리즘] BOJ 5525 IOIOI</title><link>https://honux77.github.io/post/boj-5525-ioioi/</link><pubDate>Fri, 06 Nov 2020 01:56:58 +0000</pubDate><guid>https://honux77.github.io/post/boj-5525-ioioi/</guid><description>KMP를 이용한 문자열 패턴 매칭 https://www.acmicpc.net/problem/5525 문제는 상당히 재미있는 문제였다.
Try 1 언뜻 보면 단순 문자열 비교를 통해서 풀 수 있을 것 같은 문제라 그렇게 풀어 보았다.
생각해 보면 복잡도가 O(n * m) 이기 때문에 당연히 TE (시간초과) 가 발생한다.
using namespace std; string pstr(int n) { string o = &amp;quot;IO&amp;quot;; string ans = &amp;quot;&amp;quot;; for (int i = 0; i &amp;lt; n; i++) { ans += o; } return ans + &amp;quot;I&amp;quot;; } int main() { ios_base::sync_with_stdio(false); cin.</description></item><item><title>BOJ 1927 최소 힙</title><link>https://honux77.github.io/post/boj-1927/</link><pubDate>Mon, 19 Oct 2020 23:09:08 +0000</pubDate><guid>https://honux77.github.io/post/boj-1927/</guid><description>BOJ 1927 최소 힙 BOJ 1927은 말 그대로 최소 힙을 구현하는 문제다.
풀이 1: STL 사용 cpp에서 min(max) heap은 priority_queue를 이용하면 된다.
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; using ull = long long int; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q; int n; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) { int num; cin &amp;gt;&amp;gt; num; if (num == 0) { if (q.</description></item><item><title>알고리즘 - BOJ 10814 나이순 정렬</title><link>https://honux77.github.io/post/algorithm-200929/</link><pubDate>Tue, 29 Sep 2020 13:13:00 +0900</pubDate><guid>https://honux77.github.io/post/algorithm-200929/</guid><description>BOJ BOJ 10814 나이순 정렬 문제는 간단한 정렬문제이다.
다만 기본 정렬인 퀵정렬은 불안전 정렬이기 때문에 안정정렬을 사용해야 한다.
실패 분석 출력이 많은데 endl을 사용하면 시간초과가 발생한다. 그 사실을 모르고 복잡도 때문인지 알고 카운팅 소트를 구현해서 사용했다. 안정 정렬 구현 코드 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; using i64 = long long int; struct People { int age; string name; }; bool cmp(const People &amp;amp;a, const People &amp;amp;b) { return a.</description></item><item><title>알고리즘 - BOJ 10972 다음 순열</title><link>https://honux77.github.io/post/algorithm-200905/</link><pubDate>Sat, 05 Sep 2020 15:23:57 +0900</pubDate><guid>https://honux77.github.io/post/algorithm-200905/</guid><description>BOJ BOJ 10972 다음 순열 문제는 말 그대로 사전순으로 다음 순열을 찾는 문제다.
일종의 Brute force 문제인데, 구현이 쉽지 않았다.
아이디어 단계 1 역순 정렬되어 있으면 다음 순열이 없으므로 -1 을 출력한다. 처음 바꿔야 하는 숫자를 뒤에서 앞으로 순회하며 찾는다. 대상은 자신의 값이 뒷자리보다 작은 숫자 예1: 1, 2, 3, [4], 5 라면 4가 해당 예2: 1, [2], 5, 4, 3 이라면 2가 해당 단계 2 이번에는 찾은 숫자 a와 바꿀 숫자 b를 다시 뒤에서부터 찾는다.</description></item></channel></rss>