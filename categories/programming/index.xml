<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on Honux BBS</title><link>https://honux77.github.io/categories/programming/</link><description>Recent content in programming on Honux BBS</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sat, 02 Jan 2021 01:51:18 +0000</lastBuildDate><atom:link href="https://honux77.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>백기선 자바 스터디 6: 상속</title><link>https://honux77.github.io/post/6/</link><pubDate>Sat, 02 Jan 2021 01:51:18 +0000</pubDate><guid>https://honux77.github.io/post/6/</guid><description>자바 상속 Class Hero extends Animal implements SuperNatural {} 일반 클래스 상속은 extends 인터페이스 구현은 implements 키워드를 사용한다. 기존 클래스를 재사용해서 새로운 클래스를 만든다. 객체를 생성할 수 없는 추상 클래스를 상속해서 객체 생성 가능한 클래스를 만들 수 있다. 인터페이스를 구현해서 객체간의 프로토콜(규약)을 맞추는데 사용할 수 있다. extends를 이용한 상속은 단일상속만을 허용한다. (C++은 다중상속) 상속은 Is-a 관계가 성립한다. Object 모든 클래스의 조상 모든 클래스는 toString(), equals(Object obj) 등 약 10개 정도의 메소드를 상속받는다.</description></item><item><title>백기선 자바 스터디 2: 타입, 변수, 배열</title><link>https://honux77.github.io/post/2/</link><pubDate>Sat, 02 Jan 2021 01:36:19 +0000</pubDate><guid>https://honux77.github.io/post/2/</guid><description>자바 프리미티브 타입 오라클 튜토리얼 자바독 Data Type Default Value (for fields) min max byte 0 -128 127 short 0 -32768 32767 int 0 -2^31 2^31 - 1 long 0L -2^63 2^63 -1 float 0.0f 32bit single precision (IEEE754 참고) double 0.0d 64bit double precision char &amp;lsquo;\u0000&amp;rsquo; &amp;lsquo;\u0000&amp;rsquo; &amp;lsquo;\uffff&amp;rsquo; boolean false false true 참고로 String 및 Object의 기본값은 null 이다.</description></item><item><title>백기선 자바 스터디 4: 조건문과 반복문</title><link>https://honux77.github.io/post/4/</link><pubDate>Thu, 17 Dec 2020 07:21:17 +0000</pubDate><guid>https://honux77.github.io/post/4/</guid><description>조건문 오라클 스펙 링크
기본 사용법 IfThenStatement: if ( Expression ) Statement IfThenElseStatement: if ( Expression ) StatementNoShortIf else Statement IfThenElseStatementNoShortIf: if ( Expression ) StatementNoShortIf else StatementNoShortIf 반복문 기본 for loop BasicForStatement: for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement Enhanced for loop EnhancedForStatement: for ( FormalParameter : Expression ) Statement 간단 예제 import java.util.ArrayList; import java.util.List; List &amp;lt;Integer&amp;gt; a = new ArrayList&amp;lt;(); for (int i = 0; i &amp;lt; 5; i++) { a.</description></item><item><title>JS 클래스와 TS static 키워드에 대한 짧은 고찰</title><link>https://honux77.github.io/post/js-ts-static/</link><pubDate>Tue, 15 Dec 2020 16:11:07 +0000</pubDate><guid>https://honux77.github.io/post/js-ts-static/</guid><description>요즘 인프런 캡틴 팡요님의 TS강의를 듣고 있다가 생각나서 짧게 정리해 보았다.
예전에 ES6의 클래스 문법을 사용하면서, 기존 자바에서 사용하던 static 메소드와 static 변수를 사용하고 싶었는데, 잘 되지 않았던 기억이 있었다.
이 문제를 해결하기 위한 아이디어가 갑자기 떠올랐는데, TS로 코딩을 하고 컴파일을 해서 생성된 코드를 보는 것이다!
먼저 TS에는 당연히 static 메소드와 static 변수가 있으니까 이를 이용해서 코드를 짜 보았다.
class Dog { public name: string; private age: number; public static numTail: number; constructor(name, age) { this.</description></item><item><title>백기선 자바 스터디 3: 다양한 연산자</title><link>https://honux77.github.io/post/3/</link><pubDate>Sat, 05 Dec 2020 03:02:24 +0000</pubDate><guid>https://honux77.github.io/post/3/</guid><description>Jshell 사용하기 우선순위같은 간단한 코드를 테스트하기엔 Jshell도 좋다. 터미널에서 jshell 또는 IntelliJ에서 tools - run jshell로 실행 가능하다.
우선순위 . [] () : 참조연산자, 배열 첨자, 괄호가 제일 높다! ! ~ &amp;amp; | ^ - ++ --: 단항연산자도 우선순위가 높다. 부정 &amp;gt; bit &amp;gt; 부호 &amp;gt; 증감 순으로 우선순위를 가진다. 쉬프트 연산자: 산술보다 쉬프트 연산자가 우선순위가 높다. 산술연산자 비교연산자 논리연산자 삼항연산자 대입연산자 조금 복잡하지만 단항 &amp;gt; 산술 &amp;gt; 비교 &amp;gt; 논리 &amp;gt; 삼항 &amp;gt; 대입이기 때문에 자연스럽다!</description></item><item><title>백기선 자바 스터디 1: JVM과 자바 실행</title><link>https://honux77.github.io/post/1-jvm/</link><pubDate>Tue, 17 Nov 2020 02:36:47 +0000</pubDate><guid>https://honux77.github.io/post/1-jvm/</guid><description>Java Virtual Machine (JVM) [위키 링크](https://en.wikipedia.org/wiki/Java_virtual_machine_ 자바 프로그램을 실행할 수 있는 가상 머신 바이트코드로 컴파일할수 있는 다른 프로그래밍 언어(Kotlin, Groovy) 도 실행할 수 있다. JVM 위에서 돌아가는 프로그래밍 언어도 만들 수 있을 것 같다. 유튜브 링크 .java 컴파일 터미널에서 컴파일하는 방법이 가장 간단 javac &amp;lt;옵션&amp;gt; &amp;lt;소스파일&amp;gt; 유용한 옵션 javac --help 로 옵션을 확인할 수 있다.
--class-path &amp;lt;path&amp;gt;, -classpath &amp;lt;path&amp;gt;, -cp &amp;lt;path&amp;gt; Specify where to find user class files and annotation processors -d &amp;lt;directory&amp;gt; Specify where to place generated class files -g Generate all debugging info --help, -help, -?</description></item><item><title>RFC 읽고 GitHub Oauth2 인증 구현해 보기</title><link>https://honux77.github.io/post/rfc-github-oauth2/</link><pubDate>Mon, 16 Nov 2020 12:35:47 +0000</pubDate><guid>https://honux77.github.io/post/rfc-github-oauth2/</guid><description>최근 강의 준비를 위해 RFC6749를 읽었다.
생각보다 설명이 잘 되어 있고 읽기가 편한 편이다.
시험 삼아 별도 모듈 없이 직접 node.js + express로 구현을 해 봤다. 다행히 잘 된다.
인증 과정 요약 GitHub(Authentication Server) 에서 제공하는 url을 통해 **사용자(resource owner)**는 **서비스(client)**가 scope로 미리 정의한 요청 권한을 직접 확인하고 grant한다. 결과물로 authorization code가 나온다. 서비스는 callback URL을 통해 사용자로부터 전달받은 code에 client id, secret을 함께 묶어서 인증 서버로 보내면 access token을 얻을 수 있다.</description></item></channel></rss>